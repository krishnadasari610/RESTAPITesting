<?xml version="1.0" encoding="UTF-8"?>
<con:soapui-project id="1836ed24-dbae-4fd1-bfaf-96d34c09e9b3" created="2.6.0" activeEnvironment="Default environment" name="Project 1" resourceRoot="" updated="2.7.0 2019-05-30T13:25:24Z" encryptionMode="Not encrypted" xmlns:con="http://eviware.com/soapui/config">
  <con:settings>
    <con:setting id="com.eviware.soapui.impl.wsdl.actions.iface.tools.soapui.ProTestRunnerAction@values-local"><![CDATA[<xml-fragment xmlns:con="http://eviware.com/soapui/config">
  <con:entry key="Report Format(s)" value="XML"/>
  <con:entry key="Host:Port" value=""/>
  <con:entry key="Export JUnit Results" value="true"/>
  <con:entry key="Export All" value="true"/>
  <con:entry key="Save After" value="true"/>
  <con:entry key="Slack Channel(s)" value="U82GUR5HB,UFA0P83ND,#testing-notif"/>
  <con:entry key="Add Settings" value="false"/>
  <con:entry key="WSS Password Type" value=""/>
  <con:entry key="Endpoint" value=""/>
  <con:entry key="Test Suite Tags" value=""/>
  <con:entry key="Select Report Type" value="JUnit-Style report for automation"/>
  <con:entry key="System Properties" value=""/>
  <con:entry key="Test Suite" value="ConfigsValidation"/>
  <con:entry key="Run in-process" value="false"/>
  <con:entry key="Password" value=""/>
  <con:entry key="Print Report" value="true"/>
  <con:entry key="Open Report" value="false"/>
  <con:entry key="Test Case Tags" value=""/>
  <con:entry key="Export JUnit Results with test properties" value="false"/>
  <con:entry key="Global Properties" value=""/>
  <con:entry key="Project Properties" value=""/>
  <con:entry key="Test Case" value="&lt;all>"/>
  <con:entry key="Slack Access Token" value="xoxb-559250300642-559217769268-OcsZbY435W4n1v9VSM8dLpji"/>
  <con:entry key="Project Password" value=""/>
  <con:entry key="Username" value=""/>
  <con:entry key="user-settings.xml Password" value=""/>
  <con:entry key="TestRunner Path" value="/home/ubuntu1/SmartBear/ReadyAPI-2.6.0/bin"/>
  <con:entry key="Environment" value="Default environment"/>
  <con:entry key="Coverage Report" value="false"/>
  <con:entry key="Enable UI" value="true"/>
  <con:entry key="Root Folder" value="c:\temp\Slack"/>
  <con:entry key="Ignore Errors" value="true"/>
  <con:entry key="Domain" value=""/>
  <con:entry key="Tool Args" value="-Wxoxp-559250300642-559250300818-559261860114-26877de6624e9ec7f7e5d023a47afc3b/#testing-notif"/>
  <con:entry key="Save Project" value="true"/>
</xml-fragment>]]></con:setting>
    <con:setting id="com.eviware.soapui.impl.wsdl.actions.iface.tools.soapui.ProTestRunnerUIAction@values-local"><![CDATA[<xml-fragment xmlns:con="http://eviware.com/soapui/config">
  <con:entry key="Report Format(s)" value="XML"/>
  <con:entry key="Host:Port" value=""/>
  <con:entry key="Export JUnit Results" value="true"/>
  <con:entry key="Export All" value="true"/>
  <con:entry key="Save After" value="false"/>
  <con:entry key="Slack Channel(s)" value="#testing-notif,U82GUR5HB"/>
  <con:entry key="Add Settings" value="false"/>
  <con:entry key="WSS Password Type" value=""/>
  <con:entry key="Endpoint" value=""/>
  <con:entry key="Test Suite Tags" value=""/>
  <con:entry key="Select Report Type" value="JUnit-Style report for automation"/>
  <con:entry key="System Properties" value=""/>
  <con:entry key="Test Suite" value="&lt;all>"/>
  <con:entry key="Run in-process" value="false"/>
  <con:entry key="Password" value=""/>
  <con:entry key="Print Report" value="true"/>
  <con:entry key="Open Report" value="false"/>
  <con:entry key="Test Case Tags" value=""/>
  <con:entry key="Export JUnit Results with test properties" value="false"/>
  <con:entry key="Global Properties" value=""/>
  <con:entry key="Project Properties" value=""/>
  <con:entry key="Test Case" value="&lt;all>"/>
  <con:entry key="Slack Access Token" value="xoxp-275305531894-274572855589-602415148241-185d61badbc481df10df3e8f05295cfb"/>
  <con:entry key="Project Password" value=""/>
  <con:entry key="Username" value=""/>
  <con:entry key="user-settings.xml Password" value=""/>
  <con:entry key="TestRunner Path" value="/home/ubuntu1/SmartBear/ReadyAPI-2.6.0/bin"/>
  <con:entry key="Environment" value="Default environment"/>
  <con:entry key="Coverage Report" value="false"/>
  <con:entry key="Enable UI" value="false"/>
  <con:entry key="Root Folder" value="${WORKSPACE}"/>
  <con:entry key="Ignore Errors" value="false"/>
  <con:entry key="Domain" value=""/>
  <con:entry key="Tool Args" value="-Wxoxb-275305531894-597231560547-ALmoSSRpR4x26c2Pnj6etaUO"/>
  <con:entry key="Save Project" value="false"/>
</xml-fragment>]]></con:setting>
  </con:settings>
  <con:interface xsi:type="con:RestService" id="60473b8c-9146-421e-9ce8-3af2c6310073" wadlVersion="http://wadl.dev.java.net/2009/02" name="REST Service 1" type="rest" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <con:settings/>
    <con:definitionCache type="TEXT" rootPart=""/>
    <con:endpoints/>
    <con:resource name="Configs" path="/scans/configs" id="b51c64f5-dfdf-48e4-9dc3-0049dd1194a6">
      <con:settings/>
      <con:parameters/>
      <con:method name="Configs" id="bf44eefe-b4cc-454a-925b-e8a17941e24f" method="GET">
        <con:settings/>
        <con:parameters/>
        <con:representation type="RESPONSE">
          <con:mediaType xsi:nil="true"/>
          <con:status>0</con:status>
          <con:params/>
          <con:element>data</con:element>
        </con:representation>
        <con:representation type="RESPONSE">
          <con:mediaType>application/xml</con:mediaType>
          <con:status>200</con:status>
          <con:params/>
        </con:representation>
        <con:representation type="RESPONSE">
          <con:mediaType>application/json</con:mediaType>
          <con:status>200</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/scans/configs">con1:Response</con:element>
        </con:representation>
        <con:representation type="FAULT">
          <con:mediaType>application/json</con:mediaType>
          <con:status>400 415</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/scans/configs">con1:Fault</con:element>
        </con:representation>
        <con:request name="Request 1" id="9af272a1-f4d5-4d4c-ad88-96882071ea99" mediaType="application/json">
          <con:settings/>
          <con:credentials>
            <con:selectedAuthProfile>No Authorization</con:selectedAuthProfile>
            <con:authType>No Authorization</con:authType>
          </con:credentials>
          <con:parameters/>
        </con:request>
      </con:method>
    </con:resource>
    <con:resource name="/notification/alarms/configs" path="/notification/alarms/configs" id="88535a6e-1b20-4a4f-ad99-188324f77d7f">
      <con:settings/>
      <con:parameters/>
      <con:method name="GET" id="aa5c3774-b3e0-41c6-9783-782d88b3acd8" method="GET">
        <con:settings/>
        <con:parameters/>
        <con:representation type="RESPONSE">
          <con:mediaType>application/json</con:mediaType>
          <con:status>200</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/notification/alarms/configs">con1:Response</con:element>
        </con:representation>
        <con:representation type="FAULT">
          <con:mediaType>application/json</con:mediaType>
          <con:status>400</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/notification/alarms/configs">con1:Fault</con:element>
        </con:representation>
        <con:representation type="RESPONSE">
          <con:mediaType xsi:nil="true"/>
          <con:status>0</con:status>
          <con:params/>
          <con:element>data</con:element>
        </con:representation>
        <con:request name="GET" id="632003f9-0020-4db9-a8ab-894e2707e968" mediaType="application/json">
          <con:settings/>
          <con:credentials>
            <con:selectedAuthProfile>No Authorization</con:selectedAuthProfile>
            <con:authType>No Authorization</con:authType>
          </con:credentials>
          <con:parameters/>
        </con:request>
      </con:method>
    </con:resource>
    <con:resource name="/monitoring/host/status" path="/monitoring/host/status" id="38f29183-5328-4ed0-93ee-1d02ee71dd04">
      <con:settings/>
      <con:parameters/>
      <con:method name="POST" id="4c135669-d8d5-40fe-bd01-9fafc23e7ab6" method="POST">
        <con:settings/>
        <con:parameters/>
        <con:representation type="RESPONSE">
          <con:mediaType xsi:nil="true"/>
          <con:status>0</con:status>
          <con:params/>
          <con:element>data</con:element>
        </con:representation>
        <con:representation type="REQUEST">
          <con:mediaType>application/json</con:mediaType>
          <con:params/>
        </con:representation>
        <con:representation type="RESPONSE">
          <con:mediaType>application/json</con:mediaType>
          <con:status>200</con:status>
          <con:params/>
          <con:element xmlns:stat="https://localhost/monitoring/host/status">stat:Response</con:element>
        </con:representation>
        <con:request name="POST" id="725e9a9a-a547-4146-9e39-bfd4c162b450" mediaType="application/json">
          <con:settings/>
          <con:credentials>
            <con:selectedAuthProfile>No Authorization</con:selectedAuthProfile>
            <con:authType>No Authorization</con:authType>
          </con:credentials>
          <con:parameters/>
        </con:request>
      </con:method>
    </con:resource>
    <con:resource name="/monitoring/host/status/configs" path="/monitoring/host/status/configs" id="c4a80081-0be4-41bd-83c5-02c52841f2b5">
      <con:settings/>
      <con:parameters/>
      <con:method name="GET" id="45daa58e-8d65-482d-9af3-96fe151b9c40" method="GET">
        <con:settings/>
        <con:parameters/>
        <con:representation type="RESPONSE">
          <con:mediaType xsi:nil="true"/>
          <con:status>0</con:status>
          <con:params/>
          <con:element>data</con:element>
        </con:representation>
        <con:representation type="RESPONSE">
          <con:mediaType>application/json</con:mediaType>
          <con:status>200</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/monitoring/host/status/configs">con1:Response</con:element>
        </con:representation>
        <con:representation type="FAULT">
          <con:mediaType>application/json</con:mediaType>
          <con:status>400</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/monitoring/host/status/configs">con1:Fault</con:element>
        </con:representation>
        <con:request name="GET" id="41525901-2367-434c-8fd0-3f219f94d781" mediaType="application/json">
          <con:settings/>
          <con:credentials>
            <con:selectedAuthProfile>No Authorization</con:selectedAuthProfile>
            <con:authType>No Authorization</con:authType>
          </con:credentials>
          <con:parameters/>
        </con:request>
      </con:method>
    </con:resource>
    <con:resource name="/monitoring/host/belt/status" path="/monitoring/host/belt/status" id="85fddca2-35b1-4f86-abf8-23a8aca27140">
      <con:settings/>
      <con:parameters/>
      <con:method name="POST" id="572af646-a1fa-4725-a649-92cb7bf9c65e" method="POST">
        <con:settings/>
        <con:parameters/>
        <con:representation type="RESPONSE">
          <con:mediaType xsi:nil="true"/>
          <con:status>0</con:status>
          <con:params/>
          <con:element>data</con:element>
        </con:representation>
        <con:representation type="REQUEST">
          <con:mediaType>application/json</con:mediaType>
          <con:params/>
        </con:representation>
        <con:representation type="RESPONSE">
          <con:mediaType>application/json</con:mediaType>
          <con:status>200</con:status>
          <con:params/>
          <con:element xmlns:stat="https://localhost/monitoring/host/belt/status">stat:Response</con:element>
        </con:representation>
        <con:representation type="FAULT">
          <con:mediaType>application/json</con:mediaType>
          <con:status>400</con:status>
          <con:params/>
          <con:element xmlns:stat="https://localhost/monitoring/host/belt/status">stat:Fault</con:element>
        </con:representation>
        <con:request name="POST" id="444150df-7377-48c8-884f-02d70b438571" mediaType="application/json">
          <con:settings/>
          <con:credentials>
            <con:selectedAuthProfile>No Authorization</con:selectedAuthProfile>
            <con:authType>No Authorization</con:authType>
          </con:credentials>
          <con:parameters/>
        </con:request>
      </con:method>
    </con:resource>
    <con:resource name="/monitoring/host/belt/status/configs" path="/monitoring/host/belt/status/configs" id="ec7031b6-84d4-48bd-bafd-7dad4141e482">
      <con:settings/>
      <con:parameters/>
      <con:method name="GET" id="3d61aa33-9830-4958-9a6c-f592f9acca6a" method="GET">
        <con:settings/>
        <con:parameters/>
        <con:representation type="RESPONSE">
          <con:mediaType xsi:nil="true"/>
          <con:status>0</con:status>
          <con:params/>
          <con:element>data</con:element>
        </con:representation>
        <con:representation type="RESPONSE">
          <con:mediaType>application/json</con:mediaType>
          <con:status>200</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/monitoring/host/belt/status/configs">con1:Response</con:element>
        </con:representation>
        <con:request name="GET" id="f03448ea-4403-4f12-a20f-70745401b4e0" mediaType="application/json">
          <con:settings/>
          <con:credentials>
            <con:selectedAuthProfile>No Authorization</con:selectedAuthProfile>
            <con:authType>No Authorization</con:authType>
          </con:credentials>
          <con:parameters/>
        </con:request>
      </con:method>
    </con:resource>
    <con:resource name="/control/host/belt/command/configs" path="/control/host/belt/command/configs" id="9935ebf4-1f65-4163-ba4e-fffc980f0737">
      <con:settings/>
      <con:parameters/>
      <con:method name="GET" id="41254cc6-28fd-4017-bc3c-f56d868eb7c9" method="GET">
        <con:settings/>
        <con:parameters/>
        <con:request name="GET" id="478c38c8-553c-41b8-8f89-dec2286da0d4" mediaType="application/json">
          <con:settings/>
          <con:credentials>
            <con:selectedAuthProfile>No Authorization</con:selectedAuthProfile>
            <con:authType>No Authorization</con:authType>
          </con:credentials>
          <con:parameters/>
        </con:request>
      </con:method>
    </con:resource>
  </con:interface>
  <con:interface xsi:type="con:RestService" id="d61cdc17-6904-4baf-8a6b-540d358303be" wadlVersion="http://wadl.dev.java.net/2009/02" name="REST Service 2" type="rest" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <con:settings/>
    <con:definitionCache type="TEXT" rootPart=""/>
    <con:endpoints/>
    <con:resource name="/scans/configs" path="/scans/configs" id="7e767385-f590-412a-806e-55af2f0d7c8d">
      <con:settings/>
      <con:parameters/>
      <con:method name="GET" id="02ef2600-66d6-476e-adce-e401322b436c" method="GET">
        <con:settings/>
        <con:parameters/>
        <con:representation type="RESPONSE">
          <con:mediaType xsi:nil="true"/>
          <con:status>0</con:status>
          <con:params/>
          <con:element>data</con:element>
        </con:representation>
        <con:representation type="RESPONSE">
          <con:mediaType>application/json</con:mediaType>
          <con:status>200</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/scans/configs">con1:Response</con:element>
        </con:representation>
        <con:representation type="FAULT">
          <con:mediaType>application/json</con:mediaType>
          <con:status>400 415</con:status>
          <con:params/>
          <con:element xmlns:con1="https://localhost/scans/configs">con1:Fault</con:element>
        </con:representation>
        <con:request name="GET Request" id="81fdd292-f7a7-49a7-9dfa-7d6951da62d3" mediaType="application/json">
          <con:settings/>
          <con:endpoint>https://localhost:4443</con:endpoint>
          <con:request/>
          <con:credentials>
            <con:selectedAuthProfile>No Authorization</con:selectedAuthProfile>
            <con:authType>No Authorization</con:authType>
          </con:credentials>
          <con:jmsConfig JMSDeliveryMode="PERSISTENT"/>
          <con:parameters/>
        </con:request>
      </con:method>
    </con:resource>
  </con:interface>
  <con:testSuite id="7f10368e-21b7-4a5f-aecb-d00df1cc6152" name="ConfigsValidation">
    <con:settings>
      <con:setting id="GeneratableJUnitReport@Folder">/home/ubuntu1/SmartBear/ReadyAPI-2.6.0/bin/c:tempSlack/ReadyAPI reports/ConfigsValidation</con:setting>
    </con:settings>
    <con:savedRecentRuns>1</con:savedRecentRuns>
    <con:runType>SEQUENTIAL</con:runType>
    <con:testCase id="d7648f44-23c3-40ae-97d1-50a9662024f7" discardOkResults="false" failOnError="true" failTestCaseOnErrors="true" keepSession="false" name="scanConfigs" searchProperties="true" timeout="0">
      <con:settings>
        <con:setting id="IncludeOverview">true</con:setting>
        <con:setting id="IncludeResults">true</con:setting>
        <con:setting id="FlowLayout">false</con:setting>
        <con:setting id="ErrorDetails">true</con:setting>
        <con:setting id="IncludeCoverage">true</con:setting>
      </con:settings>
      <con:savedRecentRuns>1</con:savedRecentRuns>
      <con:testStep type="restrequest" name="scanConfigs-Request" id="85789632-0791-4bb1-8e0a-ef8b9f87ce89">
        <con:settings/>
        <con:config service="REST Service 1" resourcePath="/scans/configs" methodName="Configs" xsi:type="con:RestRequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
          <con:restRequest name="scanConfigs-Request" id="9af272a1-f4d5-4d4c-ad88-96882071ea99" mediaType="application/json">
            <con:settings>
              <con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting>
            </con:settings>
            <con:endpoint>https://localhost:4443</con:endpoint>
            <con:request/>
            <con:originalUri>https://localhost/scans/configs</con:originalUri>
            <con:credentials>
              <con:selectedAuthProfile>Inherit From Parent</con:selectedAuthProfile>
              <con:authType>No Authorization</con:authType>
            </con:credentials>
            <con:jmsConfig JMSDeliveryMode="PERSISTENT"/>
            <con:jmsPropertyConfig/>
            <con:parameters/>
          </con:restRequest>
        </con:config>
      </con:testStep>
      <con:testStep type="groovy" name="scanConfigs-Success Response Validation" id="29978378-a8b1-4eca-a140-b8ee8d089503">
        <con:settings/>
        <con:config>
          <script>import groovy.json.JsonBuilder 
import groovy.json.JsonSlurper  
import groovy.transform.ToString

@ToString
class ScansConfigsResponse{

	public int code 
	public String status
	public ScansConfigData data 
	
}
@ToString
class ScansConfigData {
	public PostScanConfigs post 
	//public GetScanConfigs get
   
}
@ToString
class PostScanConfigs{
	public int retryInterval
	public int timeout
	public int retryCount
	/*public Alarm(){
		
	}
	public Alarm(int retryInterval,int timeout){
		this.retryInterval=retryInterval
		this.timeout = timeout
	}
	public boolean equals (Alarm otherAlarm) {
		return this.retryInterval==otherAlarm.retryInterval &amp;&amp; this.timeout == otherAlarm.timeout
	}*/
 }
/*@ToString
class GetScanConfigs{
	public int interval
	public int timeout
}*/
//def actualResponse =context.expand('${REST Request#Response}')
def expectedResponse ='{"code": 200,"status": "success","data": {"post": {"retryInterval": 1000,"retryCount": 3,"timeout": 5000}}}'

def expectedResponseMap = new JsonSlurper().parseText(expectedResponse)
log.info "expectedResponseMap ==> " + expectedResponseMap
def expectedScansConfigsResponse = new ScansConfigsResponse(expectedResponseMap)

def actualResponse =context.expand('${scanConfigs-Request#Response}')
log.info actualResponse
def actualScansConfigsResponseMap = new JsonSlurper().parseText(actualResponse)

log.info "actualScansConfigsResponseMap ==> " + actualScansConfigsResponseMap 
def actualScansConfigsResponse = new ScansConfigsResponse(actualScansConfigsResponseMap)

assert expectedScansConfigsResponse.code ==actualScansConfigsResponse.code
assert expectedScansConfigsResponse.status.equals(actualScansConfigsResponse.status)
assert expectedScansConfigsResponse.data.post.retryInterval==actualScansConfigsResponse.data.post.retryInterval
assert expectedScansConfigsResponse.data.post.timeout == actualScansConfigsResponse.data.post.timeout
assert expectedScansConfigsResponse.data.post.retryCount == actualScansConfigsResponse.data.post.retryCount</script>
        </con:config>
      </con:testStep>
      <con:testStep type="groovy" name="scanConfigs-Bad Request Validation" id="a9506d6f-eea2-4601-ac7d-c1ad69032d01" disabled="true">
        <con:settings/>
        <con:config>
          <script>import groovy.json.JsonBuilder 
import groovy.json.JsonSlurper  
import groovy.transform.ToString

@ToString
class ScansConfigsResponse{

	public int code 
	public String status
	public String message 
	
}


def expectedResponse = '{"code": 400,"status": "error","message": "Detailed Error Message"}'

def expectedResponseMap = new JsonSlurper().parseText(expectedResponse)
log.info "expectedResponseMap ==> " + expectedResponseMap
def expectedScansConfigsResponse = new ScansConfigsResponse(expectedResponseMap)

def actualResponse =context.expand('${scanConfigs-Request#Response}')
log.info actualResponse
def actualScansConfigsResponseMap = new JsonSlurper().parseText(actualResponse)

log.info "actualScansConfigsResponseMap ==> " + actualScansConfigsResponseMap 

def actualScansConfigsResponse = new ScansConfigsResponse(actualScansConfigsResponseMap)

assert expectedScansConfigsResponse.code ==actualScansConfigsResponse.code
assert expectedScansConfigsResponse.status.equals(actualScansConfigsResponse.status)
assert expectedScansConfigsResponse.message.equals(actualScansConfigsResponse.message)</script>
        </con:config>
      </con:testStep>
      <con:testStep type="groovy" name="scanConfigs-Invalid JSON" id="5b7f72c5-bceb-41e3-beae-623c222561ec" disabled="true">
        <con:settings/>
        <con:config>
          <script>final String DB_DRIVER = 'com.mysql.jdbc.Driver';
final String DB_END_POINT = 'jdbc:mysql://localhost:3306/sample';
final String DB_USER = 'osi';
final String DB_USER_PASSWORD = 'rapiscan';

class GetConfigMetaData {

    private String clientIdentifier;
    private Date lastRespondedAt;
    private Integer retryInterval;

    GetConfigMetaData(String clientIdentifier, Date lastRespondedAt, Integer retryInterval) {
        this.clientIdentifier = clientIdentifier;
        this.lastRespondedAt = lastRespondedAt;
        this.retryInterval = retryInterval;
    }

    GetConfigMetaData() {}

    public String getClientIdentifier() {
        return this.clientIdentifier;
    }

    public Date getLastRespondedAt() {
        return this.lastRespondedAt;
    }

    public Integer getRetryInterval() {
        return this.retryInterval;
    }

    public void setClientIdentifier(String clientIdentifier) {
        this.clientIdentifier = clientIdentifier;
    }

    public void setLastRespondedAt(Date lastRespondedAt) {
        this.lastRespondedAt = lastRespondedAt;
    }

    public void setRetryInterval(Integer retryInterval) {
        this.retryInterval = retryInterval;
    }   
}

class GetConfigMetaDataDao {

    public GetConfigMetaData getConfigMetaData(String clientIdentifier) {
        def sql = Sql.newInstance(DB_END_POINT, DB_USER, DB_USER_PASSWORD, DB_DRIVER);
        sql.connection.autoCommit = false

        def sqlQuery = 'Select * from configs where clientidentification=' + clientIdentifier;

        try {
            def configMetaData = new GetConfigMetaData();
            sql.query(sqlQuery) { resultSet ->
                if (resultSet.hasNext()) {
                    def resultSetItem = resultSet.next();
                    configMetaData.setClientIdentifier(resultSetItem.getString(0));
                    configMetaData.setLastRespondedAt(resultSetItem.getTimeStamp(1));
                    configMetaData.setRetryInterval(resultSetItem.getInteger(2));
                } else {
                    return null;
                }
            }
            return configMetaData;
        } catch (Exception e) {
            sql.rollback();
            throw e;
        } finally {
            sql.close();
        }
    }
}</script>
        </con:config>
      </con:testStep>
      <con:properties/>
      <con:reportParameters/>
      <con:breakPoints>
        <con:testStepId>5b7f72c5-bceb-41e3-beae-623c222561ec</con:testStepId>
        <con:status>NONE</con:status>
        <con:properties/>
      </con:breakPoints>
      <con:breakPoints>
        <con:testStepId>a9506d6f-eea2-4601-ac7d-c1ad69032d01</con:testStepId>
        <con:status>NONE</con:status>
        <con:properties/>
      </con:breakPoints>
      <con:breakPoints>
        <con:testStepId>85789632-0791-4bb1-8e0a-ef8b9f87ce89</con:testStepId>
        <con:status>NONE</con:status>
        <con:properties/>
      </con:breakPoints>
      <con:breakPoints>
        <con:testStepId>29978378-a8b1-4eca-a140-b8ee8d089503</con:testStepId>
        <con:status>NONE</con:status>
        <con:properties/>
      </con:breakPoints>
    </con:testCase>
    <con:testCase id="6b7507d4-8cbb-4859-87ae-55b85b06c6d6" discardOkResults="false" failOnError="true" failTestCaseOnErrors="true" keepSession="false" name="notificationAlarmsConfigs" searchProperties="true" timeout="0">
      <con:settings/>
      <con:savedRecentRuns>1</con:savedRecentRuns>
      <con:testStep type="restrequest" name="notificationAlarmsConfigs-Request" id="98987555-f9bf-43ba-9b2a-4f660f37f319">
        <con:settings/>
        <con:config service="REST Service 1" resourcePath="/notification/alarms/configs" methodName="GET" xsi:type="con:RestRequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
          <con:restRequest name="notificationAlarmsConfigs-Request" id="632003f9-0020-4db9-a8ab-894e2707e968" mediaType="application/json">
            <con:settings>
              <con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting>
            </con:settings>
            <con:endpoint>https://localhost:4443</con:endpoint>
            <con:request/>
            <con:originalUri>https://localhost/notification/alarms/configs</con:originalUri>
            <con:credentials>
              <con:selectedAuthProfile>Inherit From Parent</con:selectedAuthProfile>
              <con:authType>No Authorization</con:authType>
            </con:credentials>
            <con:jmsConfig JMSDeliveryMode="PERSISTENT"/>
            <con:jmsPropertyConfig/>
            <con:parameters/>
          </con:restRequest>
        </con:config>
      </con:testStep>
      <con:testStep type="groovy" name="notificationAlarmsConfigs-Success Response Validation" id="cd0b327c-bb2c-4d67-8ee5-0ccd5f66a13f" disabled="true">
        <con:settings/>
        <con:config>
          <script><![CDATA[import groovy.json.JsonBuilder 
import groovy.json.JsonSlurper  
import groovy.transform.ToString

@ToString
class NotificationAlarmConfigsResponse{

	public int code 
	public String status
	public AlarmConfigData data 
	/*public AlarmConfigsResponse(){
		
	}
	public AlarmConfigsResponse(int code,String status,AlamConfigData data){
		this.code=code
		this.status=status
		this.data=data
		
	}
	public boolean equals(AlarmConfigsResponse otherAlarmConfigsResponse){
		return this.code==otherAlarmConfigsResponse.code && this.status.equals(otherAlarmConfigsResponse.status) && this.data.equals(	otherAlarmConfigsResponse.data) 	
		
		}*/
	
}
@ToString
class AlarmConfigData {
	public PostAlarm post 
	public GetAlarm get
   /* public AlarmConfigData(){
    	
    }
	 public AlarmConfigData(Alarm post,Alarm get){
    	         this.post=post
    	         this.get=get
    }
	public boolean equals (AlarmConfigData otherAlarmConfigData){
		return this.post.equals(otherAlarmConfigData.post.equals) && this.get.equals(otherAlarmConfigData.get)
	}*/
}
@ToString
class PostAlarm{
	public int retryInterval
	public int timeout
	/*public Alarm(){
		
	}
	public Alarm(int retryInterval,int timeout){
		this.retryInterval=retryInterval
		this.timeout = timeout
	}
	public boolean equals (Alarm otherAlarm) {
		return this.retryInterval==otherAlarm.retryInterval && this.timeout == otherAlarm.timeout
	}*/
 }
@ToString
class GetAlarm{
	public int interval
	public int timeout
}

def expectedResponse ='{ "code":200, "status":"success", "data" : { "post" : { "retryInterval" :1000, "timeout" : 2000}, "get" : { "interval" : 1000,"timeout" : 2000}}}'
def expectedResponseMap = new JsonSlurper().parseText(expectedResponse)
log.info "expectedResponseMap ==> " + expectedResponseMap
def expectedNotificationAlarmConfigsResponse = new NotificationAlarmConfigsResponse(expectedResponseMap)
def actualResponse =context.expand('${notificationAlarmsConfigs-Request#Response}')
log.info actualResponse
def actualNotificationAlarmConfigsResponseMap = new JsonSlurper().parseText(actualResponse)

log.info "actualScansConfigsResponseMap ==> " + actualNotificationAlarmConfigsResponseMap 
def actualNotificationAlarmConfigsResponse = new NotificationAlarmConfigsResponse(actualNotificationAlarmConfigsResponseMap)


assert expectedNotificationAlarmConfigsResponse.code ==actualNotificationAlarmConfigsResponse.code
assert expectedNotificationAlarmConfigsResponse.status.equals(actualNotificationAlarmConfigsResponse.status)
assert expectedNotificationAlarmConfigsResponse.data.post.retryInterval==actualNotificationAlarmConfigsResponse.data.post.retryInterval
assert expectedNotificationAlarmConfigsResponse.data.post.timeout == actualNotificationAlarmConfigsResponse.data.post.timeout
assert expectedNotificationAlarmConfigsResponse.data.get.timeout == actualNotificationAlarmConfigsResponse.data.get.timeout
assert expectedNotificationAlarmConfigsResponse.data.get.interval==actualNotificationAlarmConfigsResponse.data.get.interval]]></script>
        </con:config>
      </con:testStep>
      <con:testStep type="groovy" name="notificationAlarmsConfigs-Bad Request Validation" id="8fdd3fb0-a199-4897-ad86-34b7baa0a98a" disabled="true">
        <con:settings/>
        <con:config>
          <script>import groovy.json.JsonBuilder 
import groovy.json.JsonSlurper  
import groovy.transform.ToString

@ToString
class NotificationAlarmsConfigsResponse{

	public int code 
	public String status
	public String message 
	
}

def expectedResponse = '{"code": 400,"status": "error","message": "Detailed Error Message"}'

def expectedResponseMap = new JsonSlurper().parseText(expectedResponse)
log.info "expectedResponseMap ==> " + expectedResponseMap
def expectedNotificationAlarmsConfigsResponse = new NotificationAlarmsConfigsResponse(expectedResponseMap)

def actualResponse =context.expand('${notificationAlarmsConfigs-Request#Response}')
log.info actualResponse
def actualNotificationAlarmsConfigsResponseMap = new JsonSlurper().parseText(actualResponse)

log.info "actual NotificationAlarmsConfigsResponseMap ==> " + actualNotificationAlarmsConfigsResponseMap 

def actualNotificationAlarmsConfigsResponse = new NotificationAlarmsConfigsResponse(actualNotificationAlarmsConfigsResponseMap)

assert expectedNotificationAlarmsConfigsResponse.code ==actualNotificationAlarmsConfigsResponse.code
assert expectedNotificationAlarmsConfigsResponse.status.equals(actualNotificationAlarmsConfigsResponse.status)
assert expectedNotificationAlarmsConfigsResponse.message.equals(actualNotificationAlarmsConfigsResponse.message)</script>
        </con:config>
      </con:testStep>
      <con:properties/>
      <con:reportParameters/>
    </con:testCase>
    <con:testCase id="6bbd1f54-be15-41e4-8d3b-21afd58aded1" discardOkResults="false" failOnError="true" failTestCaseOnErrors="true" keepSession="false" name="monitoringHostStatus-Request" searchProperties="true" timeout="0">
      <con:settings/>
      <con:savedRecentRuns>1</con:savedRecentRuns>
      <con:testStep type="restrequest" name="monitoringHostStatus-Success Response" id="1d83cdf3-62a4-40f6-a80d-11603cbddce7">
        <con:settings/>
        <con:config service="REST Service 1" methodName="POST" resourcePath="/monitoring/host/status" xsi:type="con:RestRequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
          <con:restRequest name="monitoringHostStatus-Success Response" id="4c4fd5af-59c4-4d23-9ae7-e7304f6f26dd" mediaType="application/json" postQueryString="false">
            <con:settings>
              <con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting>
            </con:settings>
            <con:encoding>UTF-8</con:encoding>
            <con:endpoint>https://localhost:4443</con:endpoint>
            <con:request>{
	"machineIdentification":
	{
	"manufacturer":"Rapiscan",
	"model":"620XR",
	"uniqueId":"08:00:27:2F:2F:11"
	}
}</con:request>
            <con:originalUri>https://localhost/monitoring/host/status</con:originalUri>
            <con:credentials>
              <con:selectedAuthProfile>Inherit From Parent</con:selectedAuthProfile>
              <con:authType>No Authorization</con:authType>
            </con:credentials>
            <con:jmsConfig JMSDeliveryMode="PERSISTENT"/>
            <con:jmsPropertyConfig/>
            <con:parameters/>
          </con:restRequest>
        </con:config>
      </con:testStep>
      <con:properties/>
      <con:reportParameters/>
    </con:testCase>
    <con:testCase id="57d4745c-be02-4571-87c8-adc9d57bae42" discardOkResults="false" failOnError="true" failTestCaseOnErrors="true" keepSession="false" name="scanConfigs-Bad Request" searchProperties="true" timeout="0" disabled="true">
      <con:settings/>
      <con:savedRecentRuns>1</con:savedRecentRuns>
      <con:testStep type="groovy" name="Groovy Script" id="823cd660-68ad-44d0-8bf4-fef036b67519">
        <con:settings/>
        <con:config>
          <script>import groovy.json.JsonSlurper
import java.net.NetworkInterface 

def  filename = '/home/ubuntu/rapiscan/malibu/rules/pipeline/VAND/Evelocity_MachineDetails_Settings.txt'

 File machineDetails = new File(filename)
    information = machineDetails.getText()
    log.info information

  def myMac= "08:00:27:2F:2F:11"
  myregex = "/^[0-9a-zA-Z]{2}(:[0-9a-zA-Z]{2}){5}
  log.info myregex

  
//convert the text file to json 
/*
def inputFile = new File(filename)
def InputJSON = new JsonSlurper().parseFile(inputFile, 'UTF-8')
InputJSON.each{ println it }
//expected Machine Identification details
def expectedMachineDetails = '{"machineIdentification":{"manufacturer":"Rapiscan","model":"620XR","uniqueId":"08:00:27:2F:2F:11"}}'

StringBuilder builder = new StringBuilder(checkstring);
   String regex = "\\p{#}"; //Special character : `~!@#$%^&amp;*()-_+=\|}{]["';:/?.,>&lt;
   //change your all special characters to ""
   Pattern  pattern = Pattern.compile(regex);
   Matcher matcher = pattern.matcher(builder.toString());
   log.info(checkstring=matcher.replaceAll(""));*/</script>
        </con:config>
      </con:testStep>
      <con:testStep type="restrequest" name="Bad Request" id="10d8837f-b315-4e9b-80e3-28ea58ac4158" disabled="true">
        <con:settings/>
        <con:config service="REST Service 2" resourcePath="/scans/configs" methodName="GET" xsi:type="con:RestRequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
          <con:restRequest name="Bad Request" id="81fdd292-f7a7-49a7-9dfa-7d6951da62d3" mediaType="application/json">
            <con:settings>
              <con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting>
            </con:settings>
            <con:endpoint>https://localhost:4443</con:endpoint>
            <con:request/>
            <con:originalUri>https://localhost/scans/configs</con:originalUri>
            <con:credentials>
              <con:selectedAuthProfile>Inherit From Parent</con:selectedAuthProfile>
              <con:authType>No Authorization</con:authType>
            </con:credentials>
            <con:jmsConfig JMSDeliveryMode="PERSISTENT"/>
            <con:jmsPropertyConfig/>
            <con:parameters/>
          </con:restRequest>
        </con:config>
      </con:testStep>
      <con:properties/>
      <con:reportParameters/>
    </con:testCase>
    <con:testCase id="1ed02398-3fdd-4572-a77d-1ef0dbf288e5" discardOkResults="false" failOnError="true" failTestCaseOnErrors="true" keepSession="false" name="monitortingHostSatusConfigs" searchProperties="true" timeout="0">
      <con:settings/>
      <con:savedRecentRuns>1</con:savedRecentRuns>
      <con:testStep type="restrequest" name="monitoringHostStatusConfigs" id="c86c7a2c-ade4-453e-b74b-489b03f45d42">
        <con:settings/>
        <con:config service="REST Service 1" resourcePath="/monitoring/host/status/configs" methodName="GET" xsi:type="con:RestRequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
          <con:restRequest name="monitoringHostStatusConfigs" id="41525901-2367-434c-8fd0-3f219f94d781" mediaType="application/json">
            <con:settings>
              <con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting>
            </con:settings>
            <con:endpoint>https://localhost:4443</con:endpoint>
            <con:request/>
            <con:originalUri>https://localhost/monitoring/host/status/configs</con:originalUri>
            <con:credentials>
              <con:selectedAuthProfile>Inherit From Parent</con:selectedAuthProfile>
              <con:authType>No Authorization</con:authType>
            </con:credentials>
            <con:jmsConfig JMSDeliveryMode="PERSISTENT"/>
            <con:jmsPropertyConfig/>
            <con:parameters/>
          </con:restRequest>
        </con:config>
      </con:testStep>
      <con:properties/>
      <con:reportParameters/>
    </con:testCase>
    <con:testCase id="c8fc9da1-5083-4052-aa16-835a075334a8" discardOkResults="false" failOnError="true" failTestCaseOnErrors="true" keepSession="false" name="monitoringHostBeltStatus" searchProperties="true" timeout="0">
      <con:settings/>
      <con:savedRecentRuns>1</con:savedRecentRuns>
      <con:testStep type="restrequest" name="monitoringHostBeltStatus-Success" id="9d369a67-c14a-45a9-91b1-e9e4da80e7f3">
        <con:settings/>
        <con:config service="REST Service 1" resourcePath="/monitoring/host/belt/status" methodName="POST" xsi:type="con:RestRequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
          <con:restRequest name="monitoringHostBeltStatus-Success" id="444150df-7377-48c8-884f-02d70b438571" mediaType="application/json" postQueryString="false">
            <con:settings>
              <con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting>
            </con:settings>
            <con:endpoint>https://localhost:4443</con:endpoint>
            <con:request>{
	"machineIdentification":
	{
	"manufacturer":"Rapiscan Systems",
	"model":"620XR",
	"uniqueId":"08:00:27:2F:2F:11"
	}
}</con:request>
            <con:originalUri>https://localhost/monitoring/host/belt/status</con:originalUri>
            <con:credentials>
              <con:selectedAuthProfile>Inherit From Parent</con:selectedAuthProfile>
              <con:authType>No Authorization</con:authType>
            </con:credentials>
            <con:jmsConfig JMSDeliveryMode="PERSISTENT"/>
            <con:jmsPropertyConfig/>
            <con:parameters/>
          </con:restRequest>
        </con:config>
      </con:testStep>
      <con:properties/>
      <con:reportParameters/>
    </con:testCase>
    <con:testCase id="f2193ab1-e9f5-4bf5-b7cf-186e7dcf9ef1" discardOkResults="false" failOnError="true" failTestCaseOnErrors="true" keepSession="false" name="monitoringHostBeltStatusConfigs" searchProperties="true" timeout="0">
      <con:settings/>
      <con:savedRecentRuns>1</con:savedRecentRuns>
      <con:testStep type="restrequest" name="monitoringHostBeltStatusConfigs" id="8c4a2bd7-8bc9-4401-9a71-23d7482dbd5b">
        <con:settings/>
        <con:config service="REST Service 1" methodName="GET" resourcePath="/monitoring/host/belt/status/configs" xsi:type="con:RestRequestStep" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
          <con:restRequest name="monitoringHostBeltStatusConfigs" id="a851dd4b-43bb-494b-a703-4eec3a2eff47" mediaType="application/json">
            <con:settings>
              <con:setting id="com.eviware.soapui.impl.wsdl.WsdlRequest@request-headers">&lt;xml-fragment/></con:setting>
            </con:settings>
            <con:encoding>UTF-8</con:encoding>
            <con:endpoint>https://localhost:4443</con:endpoint>
            <con:request/>
            <con:originalUri>https://localhost/monitoring/host/belt/status/configs</con:originalUri>
            <con:credentials>
              <con:selectedAuthProfile>Inherit From Parent</con:selectedAuthProfile>
              <con:authType>No Authorization</con:authType>
            </con:credentials>
            <con:jmsConfig JMSDeliveryMode="PERSISTENT"/>
            <con:jmsPropertyConfig/>
            <con:parameters/>
          </con:restRequest>
        </con:config>
      </con:testStep>
      <con:properties/>
      <con:reportParameters/>
    </con:testCase>
    <con:properties/>
    <con:reportParameters/>
  </con:testSuite>
  <con:testSuite id="3da40039-d001-4519-861f-6aaaa4582d02" name="Reusable Suite">
    <con:settings/>
    <con:savedRecentRuns>1</con:savedRecentRuns>
    <con:runType>SEQUENTIAL</con:runType>
    <con:testCase id="2b365688-4fa7-4977-b56e-e6593ffdf6d8" discardOkResults="false" failOnError="true" failTestCaseOnErrors="true" keepSession="false" name="utils" searchProperties="true" timeout="0">
      <con:settings/>
      <con:savedRecentRuns>1</con:savedRecentRuns>
      <con:testStep type="groovy" name="Groovy Script" id="3b2b2a28-946b-45bc-8b1f-4a60b542080b">
        <con:settings/>
        <con:config>
          <script>class Sample{
	def log
	def context
	def testRunner

	def Sample(log,context,testRunner){
		this.log = log
		this.context = context
		this.testRunner = testRunner
	}

	def configValidation( 

}</script>
        </con:config>
      </con:testStep>
      <con:properties/>
      <con:reportParameters/>
    </con:testCase>
    <con:properties/>
    <con:reportParameters/>
  </con:testSuite>
  <con:restMockService id="529b07a0-ec7a-4628-9454-129d2451b84c" port="4443" path="/" host="localhost" name="REST Virtual Service 1" httpSecure="true" routeModeEnabled="false" routeUnmatchedOperation="false" addUnmatchedOperation="false" routeEndpoint="https://dev.myservice.com/">
    <con:settings/>
    <con:properties/>
    <con:constraints>
      <con:congestion>0</con:congestion>
      <con:inputBandwidth>-1</con:inputBandwidth>
      <con:outputBandwidth>-1</con:outputBandwidth>
      <con:maxThreadPoolCapacity>20</con:maxThreadPoolCapacity>
      <con:coreThreadPoolCapacity>5</con:coreThreadPoolCapacity>
      <con:virtError>
        <con:start>0</con:start>
        <con:endless>true</con:endless>
      </con:virtError>
    </con:constraints>
    <con:dataSources/>
    <con:headerValidator type="NONE"/>
    <con:restMockAction name="/scans/configs" method="GET" resourcePath="/scans/configs" id="fcdd1cea-cc18-4696-87db-7684bcde3a07">
      <con:settings/>
      <con:defaultResponse>success</con:defaultResponse>
      <con:dispatchStyle>SEQUENCE</con:dispatchStyle>
      <con:dispatchConfig/>
      <con:dispatchPath xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">import groovy.json.JsonSlurper;
import dao.HostStatusConfigs;
import dao.MachineDetails;
import util.JsonToObjectWrapper;

Date oldHitTime = null
Date newHitTime = null
//def datesArray = ['Krihna', 'Vishnu']
def datesArray = []
def jsonSlurper = new JsonSlurper()
def scansConfigs = jsonSlurper.parseText(mockRequest.getRequestContent())
assert scansConfigs instanceof Map

/*log.info(scansConfigs.machineIdentification.manufacturer)
log.info(scansConfigs.machineIdentification.model)
log.info(scansConfigs.machineIdentification.uniqueId)*/

HostStatusConfigs configs =new HostStatusConfigs()
JsonToObjectWrapper objWrapper = new JsonToObjectWrapper()
MachineDetails md = new MachineDetails()

if(oldHitTime == null)
 oldHitTime = new Date()
else 
 oldHitTime = newHitTime
 
log.info mockRequest.method
log.info mockRequest.requestContent
log.info mockRequest.getRequestHeaders()
log.info mockRequest.getPath()
log.info mockRequest.queryString.toString()
log.info "******************** Initial time = " +oldHitTime


newHitTime = new Date()
def h = new Date()

log.info("old Hit Time = " +  oldHitTime)
log.info("new Hit Time = " +  newHitTime)

datesArray =  [oldHitTime, newHitTime]
datesArray.push(oldHitTime)
log.info("==>" + datesArray[0])
log.info("==>" + datesArray[1])
log.info("==>" + datesArray[2])
log.info "==> Size = " + datesArray.size()


def g = new Date().getTime() - oldHitTime.getTime()
def diff = g * 1000/60
//hitTime = new Date()
//def r = g - hitDate.getMilliseconds()
log.info "******************* Difference" + diff
if(mockRequest.requestContent.valueOf(md.manufacturer) &amp;&amp; mockRequest.getPath().valueOf(md.uniqueId) &amp;&amp; mockRequest.getPath().valueOf(md.model)){
	
	return "scanConfigs -Success Response"
}else{
	return "Machine details are not matching"
}






/*def queryString = mockRequest.getQueryString()                       
log.info "QueryString: " + queryString

if( queryString.contains("") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}*/

 /*configs.setRetryCount(3)
 md.setManufacturer(Rapiscan Systems)
 configs.getRetryCount()*/




/*
// Script dispatcher is used to select a response based on the incoming request.
// Here are few examples showing how to match based on path, query param, header and body

// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeaderList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncoding Header List: " + acceptEncodingHeaderList

if( acceptEncodingHeaderList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}


// Match based on body
def requestBody = mockRequest.getRequestContent()
log.info "Request body: " + requestBody

if( requestBody.contains("some data") )
{
    // return the name of the response you want to dispatch
    return "Response N"
}
*/</con:dispatchPath>
      <con:dispatchXPath/>
      <con:parameterDispatcherRuleContainer/>
      <con:routeEnabled>false</con:routeEnabled>
      <con:conditionalRoutingEnabled>true</con:conditionalRoutingEnabled>
      <con:routeScript>def requestPath = mockRequest.path
log.info requestPath
 if (requestPath.contains('/scans/configs')) {
    return true
} else {
    return false
}

for(hdr in mockRequest.requestHeaders){
		String ss = hdr.toString()
		log.info ss
	}
// Route script is used to dynamically route requests
// based on requests. Return true/false to indicate whether
// a request should be routed or not

/*
// Route based on path
def requestPath = mockRequest.path
if (requestPath.contains('maps22')) {
    return true
} else {
    return false
}
*/

/*
// Route based on query parameter
def queryString = mockRequest.queryString
if (queryString.contains('sensor=true')) {
    return true
} else {
    return false
}
*/

/*
// Route based on body
def requestBody = mockRequest.requestContent
if (requestBody.contains('sample')) {
    return true
} else {
    return false
}
*/

/*
// Route based on header
def headerValue = mockRequest.requestHeaders.get("Route").get(0)

if (headerValue) {
    return true
} else {
    return false
}
*/</con:routeScript>
      <con:saveRoutedResponse>false</con:saveRoutedResponse>
      <con:response name="success" id="b0f151fa-77a2-4100-adae-70b13d4084d9" httpResponseStatus="200" mediaType="application/json" compressedBodyContent="aced00057372002f636f6d2e657669776172652e736f617075692e696d706c2e737570706f72742e436f6d7072657373656456616c7565000b8b02c748eeab0200025a000a636f6d707265737365645b0004646174617400025b4278700070" dataSource="">
        <con:settings/>
        <con:responseContent>{
"code": ${#MockResponse#code},
"status": "${#MockResponse#status}",
"data": {
"post": {
"retryInterval": ${#MockResponse#retryInterval},
"retryCount": ${#MockResponse#retryCount},
"timeout": ${#MockResponse#timeout}
}
}
}</con:responseContent>
      </con:response>
    </con:restMockAction>
    <con:restMockAction name="/notification/alarms/configs" method="GET" resourcePath="/notification/alarms/configs" id="2b3945b0-bb08-49e4-8a51-21ed8582535d">
      <con:settings/>
      <con:defaultResponse xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">success</con:defaultResponse>
      <con:dispatchStyle>SEQUENCE</con:dispatchStyle>
      <con:dispatchConfig/>
      <con:dispatchPath xsi:nil="true" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>
      <con:dispatchXPath/>
      <con:parameterDispatcherRuleContainer/>
      <con:routeEnabled>false</con:routeEnabled>
      <con:conditionalRoutingEnabled>true</con:conditionalRoutingEnabled>
      <con:routeScript>def requestPath = mockRequest.path

log.info requestPath

 if (requestPath.contains('/notification/alarm/configs')) {
    return true
} else {
    return false
}

// Route script is used to dynamically route requests
// based on requests. Return true/false to indicate whether
// a request should be routed or not

/*
// Route based on path
def requestPath = mockRequest.path
if (requestPath.contains('maps22')) {
    return true
} else {
    return false
}
*/

/*
// Route based on query parameter
def queryString = mockRequest.queryString
if (queryString.contains('sensor=true')) {
    return true
} else {
    return false
}
*/

/*
// Route based on body
def requestBody = mockRequest.requestContent
if (requestBody.contains('sample')) {
    return true
} else {
    return false
}
*/

/*
// Route based on header
def headerValue = mockRequest.requestHeaders.get("Route").get(0)

if (headerValue) {
    return true
} else {
    return false
}
*/</con:routeScript>
      <con:saveRoutedResponse>false</con:saveRoutedResponse>
      <con:response name="success" id="5306d9e6-e2f9-458f-b8db-923921722f01" httpResponseStatus="200" compressedBodyContent="aced00057372002f636f6d2e657669776172652e736f617075692e696d706c2e737570706f72742e436f6d7072657373656456616c7565000b8b02c748eeab0200025a000a636f6d707265737365645b0004646174617400025b4278700070" mediaType="application/json" dataSource="">
        <con:settings/>
        <con:script/>
        <con:responseContent>{
"code": 200,
"status": "success",
"data": {
"post": {
"retryInterval": 1000,
"timeout": 2000
},
"get": {
"interval": 1000,
"timeout": 2000
}
}
}</con:responseContent>
      </con:response>
    </con:restMockAction>
    <con:restMockAction name="/monitoring/host/status" method="POST" resourcePath="/monitoring/host/status" id="13fae3e1-499e-4362-a658-603a9b683900">
      <con:settings/>
      <con:defaultResponse>success</con:defaultResponse>
      <con:dispatchStyle>SCRIPT</con:dispatchStyle>
      <con:dispatchConfig/>
      <con:dispatchPath>import groovy.json.JsonSlurper;
import com.eviware.soapui.support.JsonUtil
import com.eviware.soapui.support.TimeUtils
import com.eviware.soapui.support.DateUtil
import com.eviware.soapui.support.GroovyUtils


TimeUtils timeUtils  = new TimeUtils()
JsonUtil jsonUtils = new JsonUtil()
DateUtil dateUtils = new DateUtil()
GroovyUtils groovyUtils =  new GroovyUtils()


timeStamp = System.currentTimeMillis()

def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if (requestPath.contains("/monitoring/host/status") )
{
	
    // return the name of the response you want to dispatch
    return "success"
    log.info "post request time stamp : $timeStamp"
}


/*log.info md.manufacturer
log.info md.model
log.info md.uniqueId*/



/*def manufacturerName = alarmConfigRequest.machineIdentification.manufacturer
def modelName = alarmConfigRequest.machineIdentification.model
def uniqueId1 = alarmConfigRequest.machineIdentification.uniqueId
if (manufacturerName.equals('Rapiscan Systems') &amp;&amp; modelName.equals('620XRH') &amp;&amp; uniqueId.equals('08:00:27:C5:07:EE')) {
    return 'OK'
} else {
    return 'InvalidManufacturer'
}*/



/*
// Script dispatcher is used to select a response based on the incoming request.
// Here are few examples showing how to match based on path, query param, header and body

// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeaderList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncoding Header List: " + acceptEncodingHeaderList

if( acceptEncodingHeaderList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}


// Match based on body
def requestBody = mockRequest.getRequestContent()
log.info "Request body: " + requestBody

if( requestBody.contains("some data") )
{
    // return the name of the response you want to dispatch
    return "Response N"
}
*/</con:dispatchPath>
      <con:dispatchXPath/>
      <con:parameterDispatcherRuleContainer/>
      <con:routeEnabled>true</con:routeEnabled>
      <con:conditionalRoutingEnabled>true</con:conditionalRoutingEnabled>
      <con:routeScript>import groovy.json.JsonSlurper;
import dao.HostStatusConfigs;
import dao.MachineDetails;
import util.JsonToObjectWrapper;
/*HostStatusConfigs HSC = new HostStatusConfigs;
String retryCount = HSC.retryCount*/


def requestPath = mockRequest.path
log.info requestPath
 if (requestPath.contains('/monitoring/host/status'))
 {
     return true
} else {
    return false
}


for (hdr in mockRequest.requestHeaders) {

// Process a header
// For example, output it to the log
log.info(hdr.toString())

}

/*def queryString = mockRequest.queryString
if (queryString.contains('sensor=true')) {
    return true
} else {
    return false
}*/


// Route script is used to dynamically route requests
// based on requests. Return true/false to indicate whether
// a request should be routed or not

/*
// Route based on path
def requestPath = mockRequest.path
if (requestPath.contains('maps22')) {
    return true
} else {
    return false
}
*/

/*
// Route based on query parameter
def queryString = mockRequest.queryString
if (queryString.contains('sensor=true')) {
    return true
} else {
    return false
}
*/

/*
// Route based on body
def requestBody = mockRequest.requestContent
if (requestBody.contains('sample')) {
    return true
} else {
    return false
}
*/

/*
// Route based on header
def headerValue = mockRequest.requestHeaders.get("Route").get(0)

if (headerValue) {
    return true
} else {
    return false
}
*/</con:routeScript>
      <con:saveRoutedResponse>false</con:saveRoutedResponse>
      <con:response name="success" id="0337f878-eece-4a33-b57e-6e301cc0dcdc" httpResponseStatus="200" compressedBodyContent="aced00057372002f636f6d2e657669776172652e736f617075692e696d706c2e737570706f72742e436f6d7072657373656456616c7565000b8b02c748eeab0200025a000a636f6d707265737365645b0004646174617400025b4278700070" mediaType="application/json" dataSource="">
        <con:settings/>
        <con:responseContent>{
"code": 200,
"status": "success"
}</con:responseContent>
      </con:response>
    </con:restMockAction>
    <con:restMockAction name="/monitoring/host/status/configs" method="GET" resourcePath="/monitoring/host/status/configs" id="c02bb933-ad2b-446d-886f-f9b023bae2ce">
      <con:settings/>
      <con:defaultResponse>success</con:defaultResponse>
      <con:dispatchStyle>SCRIPT</con:dispatchStyle>
      <con:dispatchConfig/>
      <con:dispatchPath>import groovy.json.JsonSlurper;
import com.eviware.soapui.support.JsonUtil
import com.eviware.soapui.support.TimeUtils
import com.eviware.soapui.support.DateUtil
import com.eviware.soapui.support.GroovyUtils

TimeUtils timeUtil =  new TimeUtils()

def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

timeStamp = System.currentTimeMillis()

if( requestPath.contains("/monitoring/host/status/configs") )
{
	//log.info "Incoming request time : $timeStamp"
	
	log.info "$timeStamp"
	
    // return the name of the response you want to dispatch
    return "success"
}

/*
// Script dispatcher is used to select a response based on the incoming request.
// Here are few examples showing how to match based on path, query param, header and body

// Match based on path
def requestPath = mockRequest.getPath()
log.info "Path: "+ requestPath

if( requestPath.contains("json") )
{
    // return the name of the response you want to dispatch
    return "JSON Response"
}


// Match based on query parameter
def queryString = mockRequest.getRequest().getQueryString()
log.info "QueryString: " + queryString

if( queryString.contains("stockholm") )
{
    // return the name of the response you want to dispatch
    return "Response Stockholm"
}
else if( queryString.contains("london") )
{
    // return the name of the response you want to dispatch
    return "Response London"
}


// Match based on header
def acceptEncodingHeaderList = mockRequest.getRequestHeaders().get("Accept-Encoding")
log.info "AcceptEncoding Header List: " + acceptEncodingHeaderList

if( acceptEncodingHeaderList.contains("gzip,deflate") )
{
    // return the name of the response you want to dispatch
    return "GZiped Response"
}


// Match based on body
def requestBody = mockRequest.getRequestContent()
log.info "Request body: " + requestBody

if( requestBody.contains("some data") )
{
    // return the name of the response you want to dispatch
    return "Response N"
}
*/</con:dispatchPath>
      <con:dispatchXPath/>
      <con:parameterDispatcherRuleContainer/>
      <con:routeEnabled>false</con:routeEnabled>
      <con:conditionalRoutingEnabled>true</con:conditionalRoutingEnabled>
      <con:routeScript>def requestPath = mockRequest.path
 if (requestPath.contains('/monitoring/host/status/configs')) {
    return true
} else {
    return false
}


// Route script is used to dynamically route requests
// based on requests. Return true/false to indicate whether
// a request should be routed or not

/*
// Route based on path
def requestPath = mockRequest.path
if (requestPath.contains('maps22')) {
    return true
} else {
    return false
}
*/

/*
// Route based on query parameter
def queryString = mockRequest.queryString
if (queryString.contains('sensor=true')) {
    return true
} else {
    return false
}
*/

/*
// Route based on body
def requestBody = mockRequest.requestContent
if (requestBody.contains('sample')) {
    return true
} else {
    return false
}
*/

/*
// Route based on header
def headerValue = mockRequest.requestHeaders.get("Route").get(0)

if (headerValue) {
    return true
} else {
    return false
}
*/</con:routeScript>
      <con:saveRoutedResponse>false</con:saveRoutedResponse>
      <con:response name="success" id="28a3d30e-8059-4ff2-b549-a4df97b48ee7" httpResponseStatus="200" compressedBodyContent="aced00057372002f636f6d2e657669776172652e736f617075692e696d706c2e737570706f72742e436f6d7072657373656456616c7565000b8b02c748eeab0200025a000a636f6d707265737365645b0004646174617400025b4278700070" mediaType="application/json" dataSource="">
        <con:settings/>
        <con:responseContent>{
"code": 200,
"status": "success",
"data": {
"post": {
"interval": 5000,
"retryInterval": 2000,
"retryCount": 3,
"timeout": 2000
}
}
}</con:responseContent>
      </con:response>
    </con:restMockAction>
    <con:restMockAction name="/monitoring/host/belt/status" method="POST" resourcePath="/monitoring/host/belt/status" id="a08e0ded-646a-4031-80e5-9c8cf51faceb">
      <con:settings/>
      <con:dispatchStyle>SEQUENCE</con:dispatchStyle>
      <con:dispatchConfig/>
      <con:dispatchXPath/>
      <con:routeEnabled>false</con:routeEnabled>
      <con:conditionalRoutingEnabled>true</con:conditionalRoutingEnabled>
      <con:routeScript>def requestPath = mockRequest.path
 if (requestPath.contains('/monitoring/host/belt/status')) {
    return true
} else {
    return false
}


// Route script is used to dynamically route requests
// based on requests. Return true/false to indicate whether
// a request should be routed or not

/*
// Route based on path
def requestPath = mockRequest.path
if (requestPath.contains('maps22')) {
    return true
} else {
    return false
}
*/

/*
// Route based on query parameter
def queryString = mockRequest.queryString
if (queryString.contains('sensor=true')) {
    return true
} else {
    return false
}
*/

/*
// Route based on body
def requestBody = mockRequest.requestContent
if (requestBody.contains('sample')) {
    return true
} else {
    return false
}
*/

/*
// Route based on header
def headerValue = mockRequest.requestHeaders.get("Route").get(0)

if (headerValue) {
    return true
} else {
    return false
}
*/</con:routeScript>
      <con:saveRoutedResponse>false</con:saveRoutedResponse>
      <con:response name="success" id="6ebe12f7-a15c-4e95-8560-0743f8029234" httpResponseStatus="200" compressedBodyContent="aced00057372002f636f6d2e657669776172652e736f617075692e696d706c2e737570706f72742e436f6d7072657373656456616c7565000b8b02c748eeab0200025a000a636f6d707265737365645b0004646174617400025b4278700070" mediaType="application/json" dataSource="">
        <con:settings/>
        <con:responseContent>{
"code": 200,
"status": "success"
}</con:responseContent>
      </con:response>
    </con:restMockAction>
    <con:restMockAction name="/monitoring/host/belt/status/configs" method="GET" resourcePath="/monitoring/host/belt/status/configs" id="e2fd7d5e-5c34-4e27-9bf2-6d9259a4f25e">
      <con:settings/>
      <con:defaultResponse>success</con:defaultResponse>
      <con:dispatchStyle>SEQUENCE</con:dispatchStyle>
      <con:dispatchConfig/>
      <con:dispatchPath>final String DB_DRIVER = 'com.mysql.jdbc.Driver';
final String DB_END_POINT = 'jdbc:mysql://localhost:3306/sample';
final String DB_USER = 'osi';
final String DB_USER_PASSWORD = 'rapiscan';

class GetConfigMetaData {

    private String clientIdentifier;
    private Date lastRespondedAt;
    private Integer retryInterval;

    GetConfigMetaData(String clientIdentifier, Date lastRespondedAt, Integer retryInterval) {
        this.clientIdentifier = clientIdentifier;
        this.lastRespondedAt = lastRespondedAt;
        this.retryInterval = retryInterval;
    }

    GetConfigMetaData() {}

    public String getClientIdentifier() {
        return this.clientIdentifier;
    }

    public Date getLastRespondedAt() {
        return this.lastRespondedAt;
    }

    public Integer getRetryInterval() {
        return this.retryInterval;
    }

    public void setClientIdentifier(String clientIdentifier) {
        this.clientIdentifier = clientIdentifier;
    }

    public void setLastRespondedAt(Date lastRespondedAt) {
        this.lastRespondedAt = lastRespondedAt;
    }

    public void setRetryInterval(Integer retryInterval) {
        this.retryInterval = retryInterval;
    }   
}

class GetConfigMetaDataDao {

    public GetConfigMetaData getConfigMetaData(String clientIdentifier) {
        def sql = Sql.newInstance(DB_END_POINT, DB_USER, DB_USER_PASSWORD, DB_DRIVER);
        sql.connection.autoCommit = false

        def sqlQuery = 'Select * from configs where clientidentification=' + clientIdentifier;

        try {
            def configMetaData = new GetConfigMetaData();
            sql.query(sqlQuery) { resultSet ->
                if (resultSet.hasNext()) {
                    def resultSetItem = resultSet.next();
                    configMetaData.setClientIdentifier(resultSetItem.getString(0));
                    configMetaData.setLastRespondedAt(resultSetItem.getTimeStamp(1));
                    configMetaData.setRetryInterval(resultSetItem.getInteger(2));
                } else {
                    return null;
                }
            }
            return configMetaData;
        } catch (Exception e) {
            sql.rollback();
            throw e;
        } finally {
            sql.close();
        }
    }
}</con:dispatchPath>
      <con:dispatchXPath/>
      <con:parameterDispatcherRuleContainer/>
      <con:routeEnabled>false</con:routeEnabled>
      <con:conditionalRoutingEnabled>true</con:conditionalRoutingEnabled>
      <con:routeScript>def requestPath = mockRequest.path
 if (requestPath.contains('/monitoring/host/belt/status/configs')) {
    return true
} else {
    return false
}


// Route script is used to dynamically route requests
// based on requests. Return true/false to indicate whether
// a request should be routed or not

/*
// Route based on path
def requestPath = mockRequest.path
if (requestPath.contains('maps22')) {
    return true
} else {
    return false
}
*/

/*
// Route based on query parameter
def queryString = mockRequest.queryString
if (queryString.contains('sensor=true')) {
    return true
} else {
    return false
}
*/

/*
// Route based on body
def requestBody = mockRequest.requestContent
if (requestBody.contains('sample')) {
    return true
} else {
    return false
}
*/

/*
// Route based on header
def headerValue = mockRequest.requestHeaders.get("Route").get(0)

if (headerValue) {
    return true
} else {
    return false
}
*/</con:routeScript>
      <con:saveRoutedResponse>false</con:saveRoutedResponse>
      <con:response name="success" id="8c1d739b-9195-4776-81bc-89d9801b2097" httpResponseStatus="200" compressedBodyContent="aced00057372002f636f6d2e657669776172652e736f617075692e696d706c2e737570706f72742e436f6d7072657373656456616c7565000b8b02c748eeab0200025a000a636f6d707265737365645b0004646174617400025b4278700070" mediaType="application/json" dataSource="">
        <con:settings/>
        <con:responseContent>{
"code": 200,
"status": "success",
"data": {
"post": {
"interval": 2000,
"retryInterval": 1000,
"retryCount": 3,
"timeout": 2000
}
}
}</con:responseContent>
      </con:response>
    </con:restMockAction>
    <con:restMockAction name="/control/host/belt/command/configs" method="GET" resourcePath="/control/host/belt/command/configs" id="5e55a737-b9bc-4473-9915-64d222217920">
      <con:settings/>
      <con:defaultResponse>success</con:defaultResponse>
      <con:dispatchStyle>SEQUENCE</con:dispatchStyle>
      <con:dispatchConfig/>
      <con:dispatchPath xsi:nil="true" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"/>
      <con:dispatchXPath/>
      <con:parameterDispatcherRuleContainer/>
      <con:routeEnabled>false</con:routeEnabled>
      <con:conditionalRoutingEnabled>true</con:conditionalRoutingEnabled>
      <con:routeScript>def requestPath = mockRequest.path
 if (requestPath.contains('control/host/belt/command/configs')) {
    return true
} else {
    return false
}


// Route script is used to dynamically route requests
// based on requests. Return true/false to indicate whether
// a request should be routed or not

/*
// Route based on path
def requestPath = mockRequest.path
if (requestPath.contains('maps22')) {
    return true
} else {
    return false
}
*/

/*
// Route based on query parameter
def queryString = mockRequest.queryString
if (queryString.contains('sensor=true')) {
    return true
} else {
    return false
}
*/

/*
// Route based on body
def requestBody = mockRequest.requestContent
if (requestBody.contains('sample')) {
    return true
} else {
    return false
}
*/

/*
// Route based on header
def headerValue = mockRequest.requestHeaders.get("Route").get(0)

if (headerValue) {
    return true
} else {
    return false
}
*/</con:routeScript>
      <con:saveRoutedResponse>false</con:saveRoutedResponse>
      <con:response name="success" id="aac47df7-8e65-4e99-a19e-c194fee22a49" httpResponseStatus="200" compressedBodyContent="aced00057372002f636f6d2e657669776172652e736f617075692e696d706c2e737570706f72742e436f6d7072657373656456616c7565000b8b02c748eeab0200025a000a636f6d707265737365645b0004646174617400025b4278700070" mediaType="application/json" dataSource="">
        <con:settings/>
        <con:responseContent>{
"code": 200,
"status": "success",
"data": {
"get": {
"pollingMode": "standard",
"interval": 100,
"longPollingTimeout": 5000,
"timeout": 5000
}
}
}</con:responseContent>
      </con:response>
    </con:restMockAction>
  </con:restMockService>
  <con:savedRecentRuns>1</con:savedRecentRuns>
  <con:requirements/>
  <con:properties/>
  <con:wssContainer/>
  <con:databaseConnectionContainer/>
  <con:jmsConnectionContainer/>
  <con:oAuth2ProfileContainer/>
  <con:oAuth1ProfileContainer/>
  <con:reporting>
    <con:reportTemplates/>
    <con:xmlTemplates/>
    <con:xmlTemplates/>
    <con:parameters/>
    <con:parameters/>
  </con:reporting>
  <con:reporting/>
  <con:eventHandlers type="RequestFilter.filterRequest" name="RequestFilter.filterRequest">
    <con:script>// Sample event script to add custom HTTP header to all outgoing REST, SOAP and HTTP(S) calls
// This code is often used for adding custom authentication to SoapUI Pro tests

// If hardcoding the token, uncomment and change line 5
// def token = '4567'

// If your token is parameterized in Project level custom property, uncomment line 8
// def token = request.parent.testCase.testSuite.project.getProperty('auth_token').getValue()

// To modify all outgoing calls, remove comments from lines 11 to 16
// def headers = request.requestHeaders
// if (headers.containsKey('auth_token2') == false) {
//   headers.put('auth_token2', token)
//   request.requestHeaders = headers
// }</con:script>
  </con:eventHandlers>
  <con:eventHandlers type="TestRunListener.afterStep" name="TestRunListener.afterStep">
    <con:script>// Save all test step results into files
// Change the directory path in line 5 to a location where you want to store details
// then uncomment lines 5 to 10

// filePath = 'C:\\tempOutputDirectory\\'
// fos = new FileOutputStream(filePath + testStepResult.testStep.label + '.txt', true)
// pw = new PrintWriter(fos)
// testStepResult.writeTo(pw)
// pw.close()
// fos.close()</con:script>
  </con:eventHandlers>
  <con:authRepository/>
  <con:tags/>
</con:soapui-project>
